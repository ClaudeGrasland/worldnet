---
title: "Network analysis"
editor: visual
bibliography: references.bib
---


```{r packages}
library(quanteda, quiet=T)
#library(readr)
library(knitr)
#library(ggplot2)
library(data.table)
#library(lubridate, quiet=T)
#library(tidytext, quiet=T)
#library(stringr)
#library(visNetwork, quietly = T)
library(dplyr)
library(reshape2)
library(igraph)
library(pheatmap)
library(RColorBrewer)



# function
hc_filter <- function(don = hc,
                      who = "who",
                      when = "when",
                      where1 = "where1",
                      where2 = "where2",
                      wgt = "tags",
                      self = FALSE,
                      when_start = NA,
                      when_end = NA,
                      who_exc = NA,
                      who_inc = NA,
                      where1_exc = NA,
                      where1_inc = NA,
                      where2_exc = NA,
                      where2_inc = NA)

{                          
  
  df<-data.table(who = don[[who]],
                 when = don[[when]],
                 where1 = don[[where1]],
                 where2 = don[[where2]],
                 wgt = don[[wgt]])
  
  
  # Select time period
  if (is.na(when_start[1])==FALSE) { 
    df <- df[when >= as.Date(when_start), ]}
  if (is.na(when_end[1])==FALSE) { 
    df <- df[when <= as.Date(when_end), ]}
  # Select who
  if (is.na(who_exc[1])==FALSE) { 
    df <- df[!(who %in% who_exc), ]}
  if (is.na(who_inc[1])==FALSE) { 
    df <- df[(who %in% who_inc), ]}
  # Select where1
  if (is.na(where1_exc[1])==FALSE) { 
    df <- df[!(where1 %in% where1_exc), ]}
  if (is.na(where1_inc[1])==FALSE) { 
    df <- df[(where1 %in% where1_inc), ]}
  # Select where2
  if (is.na(where2_exc[1])==FALSE) { 
    df <- df[!(where2 %in% where2_exc), ]}
  if (is.na(where2_inc[1])==FALSE) { 
    df <- df[(where2 %in% where2_inc), ]}
  # eliminate internal links
  if (self==FALSE) { 
    df <- df[(where1 != where2), ]}
  return(df)
  
}

# Application


######## Create complete interaction matrix ########

build_int <- function(don = don,       # a dataframe with columns i, j , Fij
                      i = "where1",
                      j = "where2",
                      Fij = "wgt",
                      s1 = 5,
                      s2 = 5,
                      n1 = 3,
                      n2 = 3,
                      k = 0)
 
# Function 
{  
  df<-data.table(i=don[[i]],j=don[[j]],Fij=don[[Fij]])
  #
  int <-df[,.(Fij=sum(Fij)),.(i,j)]
  int<-dcast(int,formula = i~j,fill = 0)
  mat<-as.matrix(int[,-1])
  row.names(mat)<-int$i
  mat<-mat[apply(mat,1,sum)>=s1,apply(mat,2,sum)>=s2 ]
  m0<-mat
  m0[m0<k]<-0
  m0[m0>=k]<-1
  mat<-mat[apply(m0,1,sum)>=n1,apply(m0,2,sum)>=n2 ]
  int<-reshape2::melt(mat)
  names(int) <-c("i","j","Fij")
  return(int)
}


```




## Objective

The analysis of the different networks linking states and macroregions has been initially focused on exploratory methods but with a (too) important focus on the research of nice forms of dynamic viusalization using the `VisNetwork`package. This step was certainly important for the validation of the dictionaries and the discoveries of potential problems. But it has also limited the level of reflexion on the conceptual questions related to the definition of the network and conceptual questions. More, it has created a kind of 'trap' because `Visnetwork`is not dedicated to the computation of relevant tools for mathematical analysis of network and is not necessarily the more interesting package for visualization.

It appears therefore more relevant to proceed no to an opposite approach where we will use `igraph` package for the exploration of networks in statistical and mathematical sense i.e. computation of relevant indexes describing the whole network (e.g. fragmentation), the vertices and the edges (e.g. centrality, betweeness, ...). An output of the analysis will typically be the storage of subgraphs in the format of `igraph` as it is very clear that all networks packages available in R use today these format as reference and can import or export it. Having stored networks in igraph format make normally easy the use of any kind of visualization tools (VisNetwork, ggraph, gephi, ...).

Other packages should also be considered in this section like `backbone`which is a high level tool of reduction of networks based on interesting conceptual hypothesis @serrano2009a.


## NETWORK CREATION

We start by the example of a matrix linking states and macro-region that will create a **dual-mode network** also called **bipartite graph**.

### Import hypercube

We choose as example the linkages between states and macroregion generated by the french media Le Figaro. The weight associated is the *number of days* where the link has been observed.

```{r}
mylang <-"en"
mymedia <- c("fr_FRA_figaro")

#######  Preparation #############
hc<-readRDS("hypercube/hc_sta_reg_day.RDS") %>% 
  filter(where1 !="_no_", where2 != "_no_") %>% 
  filter(is.na(when)==F, when < as.Date("2022-07-01"))

# Correct state table

hc$where1[substr(hc$where1,1,3)=="FRA"]<-"FRA"
hc$where1[substr(hc$where1,1,3)=="GBR"]<-"GBR"

# Load table of label and choose language
reg_def<-read.table("dict/Imageun_world_geo_def_V1.csv", sep=";",quote = '"', encoding = "UTF-8",header=T)
tab_def<-reg_def %>% filter(lang==mylang) %>% select(code,type,label)
tab_def<-tab_def[duplicated(tab_def$label)==F,]

# Adapt some long labels
tab_def$label[tab_def$code=="ST_CHN"]<-"Chine"
tab_def$label[tab_def$code=="ST_ARE"]<-"E.A.U."
tab_def$label[tab_def$code=="ST_COD"]<-"RD Congo"
tab_def$label[tab_def$code=="ST_NLD"]<-"Pays-Bas"
tab_def$label[tab_def$code=="ST_USA"]<-"USA"


# Merge regional names
lab_reg<-tab_def %>% filter(!substr(code,1,3) %in% c("ST_","CA_")) %>% select(where2=code,label2=label)
hc<-left_join(hc,lab_reg)

# Merge state names
lab_reg<-tab_def %>% filter(substr(code,1,3) %in% c("ST_")) %>%
  mutate(where1=substr(code,4,6))%>%
  select(where1,label1=label) %>% filter(duplicated(where1)==F)

hc<-left_join(hc,lab_reg)

# Correct bugs
#hc_sta_reg$label2[hc_sta_reg$label2=="Machrek"]<-"Maghreb"
#hc_sta_reg$label2[hc_sta_reg$label2=="Europe médiane"]<-"Europe centrale"

# Eliminate national links
hc<-hc[!(substr(who,4,6)== where1),]
hc<-hc[!(substr(who,4,6)== "NIR" & where1=="GBR"),]

# Add unitary weight by day
hc$day<-1




# select media
hc<-hc_filter(don = hc,
              where1 = "label1",
              where2 = "label2",
                          who_inc = mymedia,
               #           who_inc = c("de_DEU_frankf", "de_DEU_suddeu"),
               #            who_inc = c("tr_TUR_cumhur", "tr_TUR_yenisa"),
              wgt = "day",
              where2_exc = c("_no_"),
              self = FALSE
)

head(hc)
```
The data indicates for each day the existence of linkages between a macroregion and a state. We decide to have a weight equal to 1, whatever the number of news that has mentionned the dyad and whatver the number of countries eventually associated to a macroregion in the same news. Of course, different choices can be made that will not be detailed here. 


### Transform in incidence matrix

We can now transform the list of links into an incidence matrix where we can introduce different constraints :

- s1 : minimum number of days of associations of state i
- s2 : total number days of association of macroregion j
- n1 : number of  links of state i with minimal value k days 
- n1 : number of links of macroregion j with minimal value k days 
- k : threshold of links

For example, we can decide 
1. to keep only macroregions and states that has been associated during 10 days (whatever the diversity) which implies s1 = s2 = 10. 
2. to keep only macroregions and states that has been associated with three different partners with a minimum level of 2 days whihc implies k = 2 and n1 = n2 =3

Notice that the values of threshold can be asymmetric and we can decide to be more sruct for the selection of macroregion than for states or vice-versa. In the example below we can imagine that we relax the selection of macroregions to s2 = 5 and n2 = 2

```{r}
int<-build_int(don = hc,
               i="where1",
               j="where2",
               Fij = "wgt",
               s1 = 10,
               s2 = 5,
               n1 = 3,
               n2 = 2,
               k = 2
               )
tab<-dcast(int, formula = i~j, value.var = "Fij", fill = 0)
mat<-as.matrix(tab[,-1])
row.names(mat)<-tab$i
kable(mat)
```

### Import to igraph

It is easy to transform this matrix into igraph with the function  `graph_from_incidence_matrix()` and some aditionnal parameters.

```{r}

net<-graph_from_incidence_matrix(incidence = mat,
                     directed = F,
                     weighted = TRUE,
                     add.names = "name")
net
plot(net)
```

The igraph visualization is absolutely horrible but it is not a problem as it is possible at any moment to import igraph network toward other packages of visualisation. 

```{r, echo=F}
library(visNetwork)
data <- toVisNetworkData(net)
data$nodes$color<-as.factor(data$nodes$type)
levels(data$nodes$color)<-c("blue","red")
data$nodes$size<-5
data$edges$width<-1+sqrt(data$edges$weight)
data$edges$color = "orange"
visNetwork(nodes = data$nodes, edges = data$edges,) %>% visOptions(highlightNearest = list(enabled=T, degree=list(from=1,to=1)),
               nodesIdSelection = TRUE)  %>% visInteraction(navigationButtons = TRUE) %>%
    #      visLegend() %>%
    visIgraphLayout(layout ="layout.fruchterman.reingold",smooth = TRUE)


```

### Store network

We can store our network in two principle formats :

- as an incidence matrix
- as an igraph object

We do not decide immediately on the best solution and adopt the two formats.

```{r}
saveRDS(mat,"networks/Figaro_sta_reg_mat.RDS")
saveRDS(net,"networks/Figaro_sta_reg_net.RDS")
```

## SUBNETWORKS ANALYSIS

We propose here a list of simple analysis based on the extraction of subnetworks of interest. We will use a list of simple tools based on igraph and described by Katya Ognyanova on her website :

https://kateto.net/network-visualization


```{r}
net <-readRDS("networks/Figaro_sta_reg_net.RDS")
plot(net, vertex.shape="none", vertex.label=V(net)$name,
     vertex.label.color=V(net)$type+1, vertex.label.font=2, 
     vertex.label.cex=.6, edge.color="gray70",  edge.width=2)
V(net)$name
```


### Ego_networks

It is relatively easy to extract egonetworks i.e. subnetworks associated located at a given distance from a macroregion. For example, immediate neighbors are the states associated to a macroregion.

```{r}


par(mfrow=c(2,2),mar=c(0,0,3,0))

# "Mediterranean Sea" = 36
egonet<-make_ego_graph(net,order=1,nodes =c(36), mode="all")[[1]]
plot(egonet, main="Mediterranean Sea",
     vertex.shape="none", 
     vertex.label=substr(V(egonet)$name,1,4),
     vertex.label.color=V(egonet)$type+1,
     vertex.label.font=2, 
     vertex.label.cex=.6, 
     edge.color="gray70", 
     edge.width=1+10*(E(egonet)$weight)/sum(E(egonet)$weight))

# "NATO" = 38
egonet<-make_ego_graph(net,order=1,nodes =c(38), mode="all")[[1]]
plot(egonet, main="NATO",
     vertex.shape="none", 
     vertex.label=substr(V(egonet)$name,1,4),
     vertex.label.color=V(egonet)$type+1,
     vertex.label.font=2, 
     vertex.label.cex=.6, 
     edge.color="gray70", 
     edge.width=1+10*(E(egonet)$weight)/sum(E(egonet)$weight))

# "Europe" = 33
egonet<-make_ego_graph(net,order=1,nodes =c(33), mode="all")[[1]]
plot(egonet, main="Europe",
     vertex.shape="none", 
     vertex.label=substr(V(egonet)$name,1,4),
     vertex.label.color=V(egonet)$type+1,
     vertex.label.font=2, 
     vertex.label.cex=.6, 
     edge.color="gray70", 
     edge.width=1+10*(E(egonet)$weight)/sum(E(egonet)$weight))

# "EU" = 34
egonet<-make_ego_graph(net,order=1,nodes =c(34), mode="all")[[1]]
plot(egonet, main="European Union",cex.main=0.3,
     vertex.shape="none", 
     vertex.label=substr(V(egonet)$name,1,4),
     vertex.label.color=V(egonet)$type+1,
     vertex.label.font=2, 
     vertex.label.cex=.6, 
     edge.color="gray70", 
     edge.width=1+10*(E(egonet)$weight)/sum(E(egonet)$weight))




```

We can do the same for an higher order of contiguity. For example with a degred of 2, we can see what are the macroregions sharing links with the same states.


```{r}
par(mfrow=c(1,1),mar=c(0,0,3,0))

# "Mediterranean Sea" = 36
egonet<-make_ego_graph(net,order=2,nodes =c(36), mode="all")[[1]]

plot(egonet, main="Mediterranean Sea / Order 2",
     vertex.shape="none", 
     vertex.label=substr(V(egonet)$name,1,9),
     vertex.label.color=V(egonet)$type+1,
     vertex.label.font=2, 
     vertex.label.cex=.6, 
     edge.color="gray70", 
     edge.width=1+10*(E(egonet)$weight)/sum(E(egonet)$weight))


```

### Macroregion comparison

Let's now consider another problem which is the comparison of two macroregions for which we want to examine the equivalence or difference of connexion with states. We take as example the case of EU and European Union 

#### chi-square => dual choice

we can start from a purely statistical approach before to move to the problem of visualization. We select the states associated to one of the unit a minimum of 5 times and we obtain a classical contingency table with two columns and as many lines as country with weight greater or equal to five.

```{r}
mat<-readRDS("networks/Figaro_sta_reg_mat.RDS") 
mat<-mat[,c("Europe","European Union")]
colnames(mat)<-c("Europe","EU")
mat<-mat[apply(mat,1,sum)>=5,]
kable(addmargins(mat), caption = "Contingency table")
```
As EU is more frequently mentionned than Europe, we observe in the majority of case that the highest probability of association of states is with EU and they are only two exceptions in the case of Spain and Italy : 

```{r}
pct<-round(100*addmargins(prop.table(addmargins(mat,1),1),2),1)
kable(pct, caption="Probability of association")
```

An obvious solution is to use a chi-square test on the contingency table in order to discover the most significant deviation in favour of one or the other candidates for association. The use of standardized residuals make possible to visualize the states that are more likely to be associated to Europe or to EU

```{r}
chi2 <-chisq.test(mat)
chi2
res<-chi2$residuals
res<-res[order(res[,1]),]
kable(res, caption = "Standardized residuals", digits=2)
```

The fact to sort the table by the standardized residuals make possible to order the states by levels of affinity and suggest clearly here that U.K is significantly more associated to EU than to Europe (p < 0.05) and Italy is significantly more associate to Europe than to EU (p <0.05). But the other states are associated to standardized values belonging to [-2 ; +2] which means that we can not necessarily demonstrate a significant level of specialization.  We can nevertheless try to propose a classification based on the residuals which will logically identify degree of preferental association to on of the macroregions : 


```{r}

pheatmap(mat=res, cutree_rows = 3)
```

The question however is to ask if the chi-square test is really the right solution from conceptual point of view. One of the most important issue is related to the pact that we have eliminated the alternative associations of states with other macroregion and we have in a sense "obliged" the states to choose between the two alternatives of EU and Europe. 

#### chi-square => dual choice + other

Let's just consider an alternative procedure where we keep the two competing macroregions but agregate the other possible choices in a third column.

```{r}
mat<-readRDS("networks/Figaro_sta_reg_mat.RDS") 
mat1<-mat[,c(8,9)]
mat2<-apply(mat[,-c(8,9)],1,sum)
mat<-cbind(mat1,mat2)
colnames(mat)<-c("Europe","EU","Other")
mat<-mat[apply(mat,1,sum)>=5,]
kable(addmargins(mat), caption = "Contingency table")
```
With the new contingency table, we can introduce some countries that was previously eliminated because of non sufficient sample size in our dual selection like Iraq. But we notice also that new informations has been added and the probability for a country is defined now in a completely different way as we can see on table below : 


```{r}
pct<-round(100*addmargins(prop.table(addmargins(mat,1),1),2),1)
kable(pct, caption="Probability of association")
```

Our interpretation of the results is modified because we are now obliged to ask our question of preferences in two steps :

- 1. *"Is the country mainly associated to one of the two selected macroregions ?"*: Looking at the probability of "Other" we can cleary say that *Syria* is mainly associated to other macroregions (78.8 %) and the fact that EU is more frequently mentionned than Europe is not an information of major interest. On the contrary, Italy is associated to "Other" in less than 8.1% of case and the fact that Europe is a bit more mentionned than EU is one more time a detail.
- 2. *"What is the most likely choice between EU and Europe when one of the two macroregions is mentionned ?"* : The question that we answered before is now a conditional probability i.e. a question that make sense only if we control the role of the "other" choices and are ready to neglect it.

The effect of the addition of the other is much more clear when we compute the new distribution of residuals :


```{r}
chi2 <-chisq.test(mat)
chi2
res<-chi2$residuals
res<-res[order(res[,3]),]
kable(res, caption = "Standardized residuals", digits=2)
```

Looking at the distribution of standardized residuals located outside the confidence interval [-2,2] we observe a much greater diversity of situations because of the introduction of the "other" possibilities :

- *United Kingdom* : this states remains very significantly associated to EU but much more than in the dual model (t=6.62, p < 0.000) because it is significantly less associated to the "Other" macroregions (t= -5.87, p <0.001) and is independent as regard to Europe (t=0.24 p>0.10). The right conclusion is therefore not to say that UK is more associated to EU than to Europe but rather that UK is more associated to EU than to other macroregions. 
- *Germany and Italy* : this country present the same situation but with a significant association with Europe as compare to other macroregions and a positive but not significant association with EU. This two country are therefore clear members of "EUrope" but more freqhently associated to "Europe".
- *Iran* is the case of a country that is clearly more associated to "other" macroregions rather than EU or Europe (t=2.14, p < 0.05). But the low level of association is significant for EU (t=-2.05, p < 0.05) but not for Europe. In other words, the media can eventually associate Iran to "Europe" but certainly not to "EU".
- *Syria* is the case of a country that is significantly less associated to both EU and Europe than expected by a random model and is significantly more associated to other macroregions. It is out of "EUrope" ...

On peut visualiser les résidus sous la forme d'une heatmap associé à une double classification :

```{r}

pheatmap(mat=res, cutree_rows = 7)
```

Mais on peut aussi représenter les résultats sous la forme d'un graphe conservant les relations positives les plus significatives.


```{r, echo=F}
net<-graph_from_incidence_matrix(incidence = mat,
                     directed = F,
                     weighted = TRUE,
                     add.names = "name")
res<-chi2$residuals
res[mat==0]<-0
netres<-graph_from_incidence_matrix(incidence = res,
                     directed = F,
                     weighted = TRUE,
                     add.names = "name")
E(net)$res<-E(netres)$weight


data <- toVisNetworkData(net)
data$nodes$color<-as.factor(data$nodes$type)
levels(data$nodes$color)<-c("gray80","black")
data$nodes$size<-10

data$edges$width<-1+10*(data$edges$weight/max(data$edges$weight))
data$edges<-data$edges[data$edges$res >0,]
mypal<-brewer.pal(8,"YlOrRd")[4:8]
data$edges$color = cut(data$edges$res, breaks=c(0,1,2,3,4,10))
levels(data$edges$color)<-mypal

visNetwork(nodes = data$nodes, edges = data$edges,) %>% visOptions(highlightNearest = list(enabled=T, degree=list(from=1,to=1)),
               nodesIdSelection = TRUE)    %>% visInteraction(navigationButtons = TRUE) %>%
    #      visLegend() %>%
    visIgraphLayout(layout ="layout.fruchterman.reingold",smooth = TRUE)

```


