---
title: "Network analysis"
editor: visual
bibliography: references.bib
---


```{r packages}
library(quanteda, quiet=T)
#library(readr)
library(knitr)
#library(ggplot2)
library(data.table)
#library(lubridate, quiet=T)
#library(tidytext, quiet=T)
#library(stringr)
#library(visNetwork, quietly = T)
library(dplyr)
library(reshape2)
library(igraph)



# function
hc_filter <- function(don = hc,
                      who = "who",
                      when = "when",
                      where1 = "where1",
                      where2 = "where2",
                      wgt = "tags",
                      self = FALSE,
                      when_start = NA,
                      when_end = NA,
                      who_exc = NA,
                      who_inc = NA,
                      where1_exc = NA,
                      where1_inc = NA,
                      where2_exc = NA,
                      where2_inc = NA)

{                          
  
  df<-data.table(who = don[[who]],
                 when = don[[when]],
                 where1 = don[[where1]],
                 where2 = don[[where2]],
                 wgt = don[[wgt]])
  
  
  # Select time period
  if (is.na(when_start[1])==FALSE) { 
    df <- df[when >= as.Date(when_start), ]}
  if (is.na(when_end[1])==FALSE) { 
    df <- df[when <= as.Date(when_end), ]}
  # Select who
  if (is.na(who_exc[1])==FALSE) { 
    df <- df[!(who %in% who_exc), ]}
  if (is.na(who_inc[1])==FALSE) { 
    df <- df[(who %in% who_inc), ]}
  # Select where1
  if (is.na(where1_exc[1])==FALSE) { 
    df <- df[!(where1 %in% where1_exc), ]}
  if (is.na(where1_inc[1])==FALSE) { 
    df <- df[(where1 %in% where1_inc), ]}
  # Select where2
  if (is.na(where2_exc[1])==FALSE) { 
    df <- df[!(where2 %in% where2_exc), ]}
  if (is.na(where2_inc[1])==FALSE) { 
    df <- df[(where2 %in% where2_inc), ]}
  # eliminate internal links
  if (self==FALSE) { 
    df <- df[(where1 != where2), ]}
  return(df)
  
}

# Application


######## Create complete interaction matrix ########

build_int <- function(don = don,       # a dataframe with columns i, j , Fij
                      i = "where1",
                      j = "where2",
                      Fij = "wgt",
                      s1 = 5,
                      s2 = 5,
                      n1 = 3,
                      n2 = 3,
                      k = 0)
 
# Function 
{  
  df<-data.table(i=don[[i]],j=don[[j]],Fij=don[[Fij]])
  #
  int <-df[,.(Fij=sum(Fij)),.(i,j)]
  int<-dcast(int,formula = i~j,fill = 0)
  mat<-as.matrix(int[,-1])
  row.names(mat)<-int$i
  mat<-mat[apply(mat,1,sum)>=s1,apply(mat,2,sum)>=s2 ]
  m0<-mat
  m0[m0<k]<-0
  m0[m0>=k]<-1
  mat<-mat[apply(m0,1,sum)>=n1,apply(m0,2,sum)>=n2 ]
  int<-reshape2::melt(mat)
  names(int) <-c("i","j","Fij")
  return(int)
}


```




## Objective

The analysis of the different networks linking states and macroregions has been initially focused on exploratory methods but with a (too) important focus on the research of nice forms of dynamic viusalization using the `VisNetwork`package. This step was certainly important for the validation of the dictionaries and the discoveries of potential problems. But it has also limited the level of reflexion on the conceptual questions related to the definition of the network and conceptual questions. More, it has created a kind of 'trap' because `Visnetwork`is not dedicated to the computation of relevant tools for mathematical analysis of network and is not necessarily the more interesting package for visualization.

It appears therefore more relevant to proceed no to an opposite approach where we will use `igraph` package for the exploration of networks in statistical and mathematical sense i.e. computation of relevant indexes describing the whole network (e.g. fragmentation), the vertices and the edges (e.g. centrality, betweeness, ...). An output of the analysis will typically be the storage of subgraphs in the format of `igraph` as it is very clear that all networks packages available in R use today these format as reference and can import or export it. Having stored networks in igraph format make normally easy the use of any kind of visualization tools (VisNetwork, ggraph, gephi, ...).

Other packages should also be considered in this section like `backbone`which is a high level tool of reduction of networks based on interesting conceptual hypothesis @serrano2009a.


## STATES x MACROREGION

We start by the example of a matrix linking states and macro-region that will create a **dual-mode network** also called **bipartite graph**.

### Import hypercube

We choose as example the linkages between states and macroregion generated by the french media Le Figaro. The weight associated is the *number of days* where the link has been observed.

```{r}
mylang <-"en"
mymedia <- c("fr_FRA_figaro")

#######  Preparation #############
hc<-readRDS("hypercube/hc_sta_reg_day.RDS") %>% 
  filter(where1 !="_no_", where2 != "_no_") %>% 
  filter(is.na(when)==F, when < as.Date("2022-07-01"))

# Correct state table

hc$where1[substr(hc$where1,1,3)=="FRA"]<-"FRA"
hc$where1[substr(hc$where1,1,3)=="GBR"]<-"GBR"

# Load table of label and choose language
reg_def<-read.table("dict/Imageun_world_geo_def_V1.csv", sep=";",quote = '"', encoding = "UTF-8",header=T)
tab_def<-reg_def %>% filter(lang==mylang) %>% select(code,type,label)
tab_def<-tab_def[duplicated(tab_def$label)==F,]

# Adapt some long labels
tab_def$label[tab_def$code=="ST_CHN"]<-"Chine"
tab_def$label[tab_def$code=="ST_ARE"]<-"E.A.U."
tab_def$label[tab_def$code=="ST_COD"]<-"RD Congo"
tab_def$label[tab_def$code=="ST_NLD"]<-"Pays-Bas"
tab_def$label[tab_def$code=="ST_USA"]<-"USA"


# Merge regional names
lab_reg<-tab_def %>% filter(!substr(code,1,3) %in% c("ST_","CA_")) %>% select(where2=code,label2=label)
hc<-left_join(hc,lab_reg)

# Merge state names
lab_reg<-tab_def %>% filter(substr(code,1,3) %in% c("ST_")) %>%
  mutate(where1=substr(code,4,6))%>%
  select(where1,label1=label) %>% filter(duplicated(where1)==F)

hc<-left_join(hc,lab_reg)

# Correct bugs
#hc_sta_reg$label2[hc_sta_reg$label2=="Machrek"]<-"Maghreb"
#hc_sta_reg$label2[hc_sta_reg$label2=="Europe mÃ©diane"]<-"Europe centrale"

# Eliminate national links
hc<-hc[!(substr(who,4,6)== where1),]
hc<-hc[!(substr(who,4,6)== "NIR" & where1=="GBR"),]

# Add unitary weight by day
hc$day<-1




# select media
hc<-hc_filter(don = hc,
              where1 = "label1",
              where2 = "label2",
                          who_inc = mymedia,
               #           who_inc = c("de_DEU_frankf", "de_DEU_suddeu"),
               #            who_inc = c("tr_TUR_cumhur", "tr_TUR_yenisa"),
              wgt = "day",
              where2_exc = c("_no_"),
              self = FALSE
)

head(hc)
```
The data indicates for each day the existence of linkages between a macroregion and a state. We decide to have a weight equal to 1, whatever the number of news that has mentionned the dyad and whatver the number of countries eventually associated to a macroregion in the same news. Of course, different choices can be made that will not be detailed here. 


### Transform in incidence matrix

We can now transform the list of links into an incidence matrix where we can introduce different constraints :

- s1 : minimum number of days of associations of state i
- s2 : total number days of association of macroregion j
- n1 : number of  links of state i with minimal value k days 
- n1 : number of links of macroregion j with minimal value k days 
- k : threshold of links

For example, we can decide 
1. to keep only macroregions and states that has been associated during 10 days (whatever the diversity) which implies s1 = s2 = 10. 
2. to keep only macroregions and states that has been associated with three different partners with a minimum level of 2 days whihc implies k = 2 and n1 = n2 =3

Notice that the values of threshold can be asymmetric and we can decide to be more sruct for the selection of macroregion than for states or vice-versa. In the example below we can imagine that we relax the selection of macroregions to s2 = 5 and n2 = 2

```{r}
int<-build_int(don = hc,
               i="where1",
               j="where2",
               Fij = "wgt",
               s1 = 10,
               s2 = 5,
               n1 = 3,
               n2 = 2,
               k = 2
               )
tab<-dcast(int, formula = i~j, value.var = "Fij", fill = 0)
mat<-as.matrix(tab[,-1])
row.names(mat)<-tab$i
kable(mat)
```

### Import to igraph

It is easy to transform this matrix into igraph with the function  `graph_from_incidence_matrix()` and some aditionnal parameters.

```{r}

net<-graph_from_incidence_matrix(incidence = mat,
                     directed = T,
                     mode = "in",
                     weighted = TRUE,
                     add.names = "name")
net
plot(net)
```

The igraph visualization is absolutely horrible but it is not a problem as it is possible at any moment to import igraph network toward other packages of visualisation. 



```{r}
library(visNetwork)
data <- toVisNetworkData(net)
data$nodes$color<-as.factor(data$nodes$type)
levels(data$nodes$color)<-c("blue","red")
data$nodes$size<-5
data$edges$width<-1+sqrt(data$edges$weight)
data$edges$color = "orange"
visNetwork(nodes = data$nodes, edges = data$edges,) %>% visOptions(highlightNearest = list(enabled=T, degree=list(from=1,to=1)),
               nodesIdSelection = TRUE) 


```




